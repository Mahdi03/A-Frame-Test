'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = aframeMapComponent;

var _cuid = require('cuid');

var _cuid2 = _interopRequireDefault(_cuid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mapboxGL = require('mapbox-gl');

var defaultMapStyle = require('./map-style.json');

var MAP_LOADED_EVENT = 'map-loaded';
var MAP_MOVE_END_EVENT = 'map-moveend';

function parseSpacedFloats(value, count, attributeName) {

  if (!value) {
    return undefined;
  }

  var values = value;

  if (Object.prototype.toString.call(value) === '[object String]') {
    values = value.split(' ');
  }

  if (values.length !== count) {
    if (process.env.NODE_ENV !== 'production') {
      // eslint-disable-next-line no-console
      console.warn('Unable to parse value of ' + attributeName + ': ' + value + '.' + (' Expected exactly ' + count + ' space separated floats.'));
    }
    return undefined;
  }

  if (values.some(function (num) {
    return isNaN(parseFloat(num));
  })) {
    if (process.env.NODE_ENV !== 'production') {
      // eslint-disable-next-line no-console
      console.warn('Unable to parse value of ' + attributeName + ': ' + value + '. ' + 'Expected values to be floats.');
    }
    return undefined;
  }

  return values;
}

function setDimensions(aframe, id, el, width, height) {

  var element = document.querySelector('#' + id);
  element.style.width = width + 'px';
  element.style.height = height + 'px';

  aframe.utils.entity.setComponentProperty(el, 'material.width', width);
  aframe.utils.entity.setComponentProperty(el, 'material.height', height);
}

function getCanvasContainerAssetElement(id, width, height) {

  var element = document.querySelector('#' + id);

  if (!element) {
    element = document.createElement('div');
  }

  element.setAttribute('id', id);
  element.style.width = width + 'px';
  element.style.height = height + 'px';

  // This is necessary because mapbox-gl uses the offsetWidth/Height of the
  // container element to calculate the canvas size.  But those values are 0 if
  // the element (or its parent) are hidden. `position: fixed` means it can be
  // calculated correctly.
  element.style.position = 'fixed';
  element.style.left = '99999px';
  element.style.top = '0';

  if (!document.body.contains(element)) {
    document.body.appendChild(element);
  }

  return element;
}

function processMapboxCanvasElement(mapboxInstance, canvasContainer) {
  var canvas = canvasContainer.querySelector('canvas');
  canvas.setAttribute('id', (0, _cuid2.default)());
  canvas.setAttribute('crossorigin', 'anonymous');
}

function createMap(canvasId, options, done) {

  var canvasContainer = getCanvasContainerAssetElement(canvasId, options.width, options.height);

  // eslint-disable-next-line no-new
  var mapboxInstance = new mapboxGL.Map(Object.assign({
    container: canvasContainer
  }, options));

  if (!mapboxInstance.loaded()) {
    mapboxInstance.once('load', function (_) {
      mapboxInstance.resize();
      processMapboxCanvasElement(mapboxInstance, canvasContainer);
      done(mapboxInstance);
    });
  } else {
    mapboxInstance.resize();
    processMapboxCanvasElement(mapboxInstance, canvasContainer);
    done(mapboxInstance);
  }
}

function processStyle(style) {

  if (!style) {
    return defaultMapStyle;
  }

  return JSON.parse(style);
}

/**
 * @param aframe {Object} The Aframe instance to register with
 * @param componentName {String} The component name to use. Default: 'map'
 */
function aframeMapComponent(aframe, componentName) {

  /**
   * Map component for A-Frame.
   */
  aframe.registerComponent(componentName, {

    dependencies: ['geometry', 'material'],

    schema: {
      /**
       * @param {number} [pxToWorldRatio=100] - The number of pixels per world
       * unit to render the map on the plane. ie; when set to 100, will display
       * 100 pixels per 1 meter in world space.
       */
      pxToWorldRatio: { default: 100 },

      /**
       * @param {string} [style=''] - A URL-encoded JSON object of a [MapBox
       * style](https://mapbox.com/mapbox-gl-style-spec/). If none is provided,
       * a default style will be loaded.
       */
      style: { default: '' },

      /**
       * @param {int} [minZoom=0] - The minimum zoom level of the map (0-20). (0
       * is furthest out)
       */
      minZoom: { default: 0 },

      /**
       * @param {int} [maxZoom=20] - The maximum zoom level of the map (0-20). (0
       * is furthest out)
       */
      maxZoom: { default: 20 },

      /**
       * @param {int} [bearinSnap=7] - The threshold, measured in degrees, that
       * determines when the map's bearing (rotation) will snap to north. For
       * example, with a  bearingSnap of 7, if the user rotates the map within 7
       * degrees of north, the map will automatically snap to exact north.
       */
      bearingSnap: { default: 7 },

      /**
       * @param {array} [maxBounds=undefined] - If set, the map will be
       * constrained to the given bounds. Bounds are specified as 4 space
       * delimited floats. The first pair represent the south-west long/lat, the
       * second pair represent the north-east long/lat.
       */
      maxBounds: {
        default: undefined,
        type: 'array',
        parse: function parse(value) {

          var values = parseSpacedFloats(value, 4, 'maxBounds');

          if (!values) {
            return undefined;
          }

          return [[values[0], values[1]], [values[2], values[3]]];
        }
      },

      /**
       * @param {array} [center=[0, 0]] - The inital geographical centerpoint of
       * the map in long/lat order. If center is not specified in the
       * constructor options, Mapbox GL JS will look for it in the map's style
       * object. If it is not specified in the style, either, it will default to
       * [0, 0]. Represented as 2 space separated floats.
       */
      center: {
        default: [0, 0],
        type: 'array',
        parse: function parse(value) {

          var values = parseSpacedFloats(value, 2, 'center');

          if (!values) {
            return [0, 0];
          }

          return values;
        }
      },

      /**
       * @param {int} [zoom=0] - The initial zoom level of the map. If  zoom
       * is not specified in the constructor options, Mapbox GL JS will look for
       * it in the map's style object. If it is not specified in the style,
       * either, it will default to 0 .
       */
      zoom: { default: 0 },

      /**
       * @param {float} [bearing=0] - The initial bearing (rotation) of the map,
       * measured in degrees counter-clockwise from north. If  bearing is not
       * specified in the constructor options, Mapbox GL JS will look for it in
       * the map's style object. If it is not specified in the style, either, it
       * will default to 0.
       */
      bearing: { default: 0.0 },

      /**
       * @param {float} [pitch=0] - The initial pitch (tilt) of the map,
       * measured in degrees away from the plane of the screen (0-60). If  pitch
       * is not specified in the constructor options, Mapbox GL JS will look for
       * it in the map's style object. If it is not specified in the style,
       * either, it will default to  0 .
       */
      pitch: { default: 0.0 }

    },

    /**
     * Called once when component is attached. Generally for initial setup.
     */
    init: function init() {
      var _this = this;

      var geomComponent = this.el.components.geometry;

      var style = processStyle(this.data.style);

      var options = Object.assign({}, this.data, {
        style: style,
        width: geomComponent.data.width * this.data.pxToWorldRatio,
        height: geomComponent.data.height * this.data.pxToWorldRatio,
        // Required to ensure the canvas can be used as a texture
        preserveDrawingBuffer: true,
        hash: false,
        interactive: false,
        attributionControl: false,
        scrollZoom: false,
        boxZoom: false,
        dragRotate: false,
        dragPan: false,
        keyboard: false,
        doubleClickZoom: false,
        touchZoomRotate: false,
        trackResize: false
      });

      this._canvasContainerId = (0, _cuid2.default)();

      aframe.utils.entity.setComponentProperty(this.el, 'material.width', options.width);
      aframe.utils.entity.setComponentProperty(this.el, 'material.height', options.height);

      createMap(this._canvasContainerId, options, function (mapInstance) {

        _this._mapInstance = mapInstance;

        var canvasId = document.querySelector('#' + _this._canvasContainerId + ' canvas').id;

        // Pointing this aframe entity to that canvas as its source
        _this.el.setAttribute('src', '#' + canvasId);

        _this.el.emit(MAP_LOADED_EVENT);
      });
    },


    /**
     * Called when component is attached and when component data changes.
     * Generally modifies the entity based on the data.
     */
    update: function update(oldData) {
      var _this2 = this;

      // Nothing changed
      if (aframe.utils.deepEqual(oldData, this.data)) {
        return;
      }

      if (oldData.pxToWorldRatio !== this.data.pxToWorldRatio) {
        var geomComponent = this.el.components.geometry;
        var width = geomComponent.data.width * this.data.pxToWorldRatio;
        var height = geomComponent.data.height * this.data.pxToWorldRatio;
        setDimensions(aframe, this._canvasContainerId, this.el, width, height);
      }

      // Everything after this requires a map instance
      if (!this._mapInstance) {
        return;
      }

      if (oldData.style !== this.data.style) {
        var style = processStyle(this.data.style);
        this._mapInstance.setStyle(style);
      }

      if (oldData.minZoom !== this.data.minZoom) {
        this._mapInstance.setMinZoom(this.data.minZoom);
      }

      if (oldData.maxZoom !== this.data.maxZoom) {
        this._mapInstance.setmaxZoom(this.data.maxZoom);
      }

      if (oldData.maxBounds !== this.data.maxBounds) {
        this._mapInstance.setmaxBounds(this.data.maxBounds);
      }

      var jumpOptions = {};

      if (oldData.zoom !== this.data.zoom) {
        jumpOptions.zoom = this.data.zoom;
      }

      if (!aframe.utils.deepEqual(oldData.center, this.data.center)) {
        jumpOptions.center = this.data.center;
      }

      if (oldData.bearing !== this.data.bearing) {
        jumpOptions.bearing = this.data.bearing;
      }

      if (oldData.pitch !== this.data.pitch) {
        jumpOptions.pitch = this.data.pitch;
      }

      if (Object.keys(jumpOptions).length > 0) {
        // A way to signal when these async actions have completed
        this._mapInstance.once('moveend', function (_) {
          _this2.el.emit(MAP_MOVE_END_EVENT);
        });
        this._mapInstance.jumpTo(jumpOptions); // moveend
      }
    },


    /**
     * Called when a component is removed (e.g., via removeAttribute).
     * Generally undoes all modifications to the entity.
     */
    remove: function remove() {
      // TODO: Kill the map
    },


    /**
     * Called when entity pauses.
     * Use to stop or remove any dynamic or background behavior such as events.
     */
    pause: function pause() {},


    /**
     * Called when entity resumes.
     * Use to continue or add any dynamic or background behavior such as events.
     */
    play: function play() {},


    /**
     * Returns {x, y} representing a position relative to the entity's center,
     * that correspond to the specified geographical location.
     *
     * @param {float} long
     * @param {float} lat
     */
    project: function project(long, lat) {

      // The position (origin at top-left corner) in pixel space
      var _mapInstance$project = this._mapInstance.project([long, lat]),
          pxX = _mapInstance$project.x,
          pxY = _mapInstance$project.y;

      // The 3D world size of the entity


      var _el$components$geomet = this.el.components.geometry.data,
          elWidth = _el$components$geomet.width,
          elHeight = _el$components$geomet.height;


      return {
        x: pxX / this.data.pxToWorldRatio - elWidth / 2,
        // y-coord is inverted (positive up in world space, positive down in
        // pixel space)
        y: -(pxY / this.data.pxToWorldRatio) + elHeight / 2,
        z: 0
      };
    },
    unproject: function unproject(x, y) {

      // The 3D world size of the entity
      var _el$components$geomet2 = this.el.components.geometry.data,
          elWidth = _el$components$geomet2.width,
          elHeight = _el$components$geomet2.height;

      // Converting back to pixel space

      var pxX = (x + elWidth / 2) * this.data.pxToWorldRatio;
      // y-coord is inverted (positive up in world space, positive down in
      // pixel space)
      var pxY = (elHeight / 2 - y) * this.data.pxToWorldRatio;

      // Return the long / lat of that pixel on the map
      return this._mapInstance.unproject([pxX, pxY]).toArray();
    }
  });
}